{
  "name": "ðŸšš Delivery Guy (Simple)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 3
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule (Every 3h)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [200, 400]
    },
    {
      "parameters": {
        "jsCode": "// Configuration\nconst OWNER = 'Artem'; // Change this to your name\n\n// Calculate lookback time (4 hours for overlap)\nconst lookbackHours = 4;\nconst lookbackDate = new Date();\nlookbackDate.setHours(lookbackDate.getHours() - lookbackHours);\nconst afterTimestamp = Math.floor(lookbackDate.getTime() / 1000);\n\nreturn {\n  owner: OWNER,\n  lookbackHours,\n  afterTimestamp,\n  afterDate: lookbackDate.toISOString()\n};"
      },
      "id": "config",
      "name": "Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 400]
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": false,
        "limit": 50,
        "filters": {
          "q": "=newer_than:1d {order OR bestellung OR shipped OR versandt OR tracking OR sendung OR delivery OR lieferung OR zustellung OR paket OR package OR confirmation OR bestÃ¤tigung OR dispatch OR shipment OR arriving OR courier OR abholung OR zugestellt OR deine OR your}"
        },
        "options": {
          "labelIds": ["INBOX"],
          "dataPropertyAttachmentsPrefixName": "attachment_",
          "downloadAttachments": false
        }
      },
      "id": "gmail-get-emails",
      "name": "Gmail: Get Emails",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [640, 400],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter emails that are likely order/delivery related\n// This is a LIGHTWEIGHT PRE-FILTER - Claude does the real classification\nconst emails = $input.all();\nconst config = $('Config').first().json;\n\n// EXCLUDED SENDERS - skip these entirely (payment providers, newsletters, etc)\nconst EXCLUDED_SENDERS = [\n  'klarna',           // Payment provider - not delivery related\n  'paypal',           // Payment notifications\n  'stripe',           // Payment notifications\n  'newsletter',       // Marketing emails\n  'marketing',        // Marketing emails\n  'promo'             // Promotional emails\n];\n\n// Keywords in subject/snippet that indicate order/delivery emails (EN + DE)\n// NOTE: Emails from unknown senders WILL pass if they match these keywords\nconst ORDER_KEYWORDS = [\n  // English - Order lifecycle\n  'order confirmation', 'order #', 'your order', 'order placed', 'order received',\n  'shipped', 'shipping', 'has shipped', 'tracking', 'track your', 'track package',\n  'delivery', 'delivered', 'out for delivery', 'arriving', 'dispatched', 'dispatch',\n  'package', 'parcel', 'shipment', 'courier',\n  // German - Order lifecycle  \n  'bestellbestÃ¤tigung', 'bestellung', 'bestellt', 'deine bestellung',\n  'versandt', 'versand', 'sendungsverfolgung', 'verfolgen',\n  'lieferung', 'zustellung', 'zugestellt', 'unterwegs', 'abholung',\n  'paket', 'sendung', 'deine sendung', 'ihr paket'\n];\n\n// KNOWN SENDERS - these bypass keyword check as a safety net\n// This list is NOT exhaustive - smaller shops are caught via ORDER_KEYWORDS above\n// Purpose: Catch carrier emails with generic subjects like 'Deine Sendung'\nconst KNOWN_SENDERS = [\n  // Major retailers\n  'amazon', 'zalando', 'asos', 'aboutyou', 'otto', 'hm.com', 'zara',\n  'ebay', 'etsy', 'aliexpress', 'mediamarkt', 'saturn', 'ikea',\n  // Carriers (critical - their subjects are often generic)\n  'dhl', 'dpd', 'hermes', 'myhermes', 'ups', 'gls', 'fedex',\n  'post.ch', 'swisspost', 'deutschepost', 'laposte',\n  // Generic patterns that indicate delivery-related\n  'noreply', 'no-reply', 'pakete', 'delivery', 'shipping', 'logistics',\n  // Known stores from user's emails\n  'gorewear', 'massimo', 'massimodutti', 'arys'\n];\n\nconst results = [];\n\nfor (const item of emails) {\n  const email = item.json;\n  const subject = (email.Subject || email.subject || '').toLowerCase();\n  const from = (email.From || email.from || '').toLowerCase();\n  const snippet = (email.snippet || '').toLowerCase();\n  \n  // Check exclusions first\n  const isExcluded = EXCLUDED_SENDERS.some(ex => from.includes(ex));\n  if (isExcluded) continue;\n  \n  const matchesKeyword = ORDER_KEYWORDS.some(kw => \n    subject.includes(kw) || snippet.includes(kw)\n  );\n  const matchesSender = KNOWN_SENDERS.some(s => from.includes(s));\n  \n  // OR logic: keyword match OR known sender\n  if (matchesKeyword || matchesSender) {\n    const dateMs = parseInt(email.internalDate) || Date.now();\n    const dateISO = new Date(dateMs).toISOString();\n    \n    results.push({\n      json: {\n        id: email.id,\n        threadId: email.threadId,\n        subject: email.Subject || email.subject || '',\n        from: email.From || email.from || '',\n        date: dateISO,\n        snippet: email.snippet || '',\n        textPlain: email.textPlain || email.snippet || '',\n        owner: config.owner\n      }\n    });\n  }\n}\n\nif (results.length === 0) {\n  return [{ json: { noEmails: true, message: 'No order-related emails found' } }];\n}\n\nreturn results;"
      },
      "id": "filter-emails",
      "name": "Filter: Order Emails",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.noEmails }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-emails",
      "name": "Has Emails?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1080, 400]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Claude API request body with properly escaped content\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const email = item.json;\n  \n  const prompt = `You are Delivery Guy, an expert email analyzer for parcel tracking. Extract ALL order/delivery information.\n\nEmail Subject: ${email.subject || 'N/A'}\nFrom: ${email.from || 'N/A'}\nDate: ${email.date || 'N/A'}\nContent: ${email.textPlain || email.snippet || 'N/A'}\n\nRespond ONLY with valid JSON:\n{\n  \"is_order_related\": true/false,\n  \"email_type\": \"order_confirmation|shipping_notification|delivery_update|out_for_delivery|delivered|invoice|payment|return|other\",\n  \"sender_type\": \"shop|carrier|payment_provider|logistics|marketplace\",\n  \"store\": \"the ACTUAL STORE/BRAND name (see rules below)\",\n  \"mentioned_store\": \"store mentioned in carrier/payment emails, or null\",\n  \"order_ids\": [\"ALL order/reference numbers\"],\n  \"tracking_numbers\": [\"ALL tracking numbers - look for long alphanumeric codes\"],\n  \"item_description\": \"items ordered (max 100 chars)\",\n  \"amount\": number or null,\n  \"currency\": \"EUR|USD|CHF|GBP\",\n  \"status\": \"ordered|confirmed|processing|shipped|in_transit|out_for_delivery|delivered|returned|unknown\",\n  \"delivery_provider\": \"DHL|DPD|Hermes|UPS|GLS|FedEx|PostCH|other\",\n  \"tracking_url\": \"full URL containing tracking info or null\",\n  \"store_order_url\": \"URL to view order on store website or null\",\n  \"expected_delivery\": \"YYYY-MM-DD format ONLY (convert ranges to first date)\",\n  \"notes\": \"important details\"\n}\n\nCRITICAL RULES:\n1. STORE IDENTIFICATION:\n   - Payment providers (Klarna, PayPal, Stripe): set sender_type='payment_provider', extract merchant as 'store' AND 'mentioned_store'\n   - Logistics companies (BARTH+CO, DHL Fulfillment): look for 'ex. Fa.', 'fÃ¼r', 'from' to find actual store\n   - Carrier emails (Hermes, DHL, GLS, DPD): set sender_type='carrier', extract store from 'von X', 'from X', 'Sendung von X'\n\n2. URL EXTRACTION:\n   - tracking_url: URLs with 'track', 'sendung', 'parcel', 'shipment' + tracking number\n   - store_order_url: URLs with 'order', 'myaccount', 'bestellung', 'order-detail'\n\n3. DATE FORMAT:\n   - ALWAYS convert to YYYY-MM-DD\n   - '30/12/25' â†’ '2025-12-30'\n   - '03/01/26 - 07/01/26' â†’ '2026-01-03' (use first date)\n   - '1-2 Werktage' â†’ calculate from email date\n   - 'Tuesday, December 30' â†’ '2025-12-30'\n\n4. TRACKING NUMBERS (common formats):\n   - DHL: 00340434... (20 digits)\n   - Hermes: H102... or JD000...\n   - GLS: alphanumeric like YVMH7TNK\n   - Look in subject AND content`;\n\n  const requestBody = {\n    model: 'claude-sonnet-4-20250514',\n    max_tokens: 1500,\n    messages: [\n      {\n        role: 'user',\n        content: prompt\n      }\n    ]\n  };\n  \n  results.push({ json: { requestBody, emailData: email } });\n}\n\nreturn results;"
      },
      "id": "prepare-claude-request",
      "name": "Prepare Claude Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "id": "claude-analyze",
      "name": "Analyze with Claude",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1400, 500],
      "credentials": {
        "httpHeaderAuth": {
          "id": "CLAUDE_CREDENTIAL_ID",
          "name": "Claude Api Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Claude responses - process ALL items (v2 with arrays support)\nconst allResponses = $input.all();\nconst allPrepared = $('Prepare Claude Request').all();\nconst results = [];\n\nfor (let i = 0; i < allResponses.length; i++) {\n  const response = allResponses[i].json;\n  const emailData = allPrepared[i]?.json?.emailData || {};\n  \n  let analysis;\n  try {\n    const content = response.content?.[0]?.text || '{}';\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    analysis = jsonMatch ? JSON.parse(jsonMatch[0]) : { is_order_related: false };\n  } catch (e) {\n    analysis = { is_order_related: false, error: e.message };\n  }\n  \n  if (!analysis.is_order_related) {\n    results.push({ json: { skip: true, reason: analysis.email_type || 'not_order_related', emailId: emailData.id } });\n    continue;\n  }\n  \n  // Normalize arrays (handle both old single values and new arrays)\n  const orderIds = Array.isArray(analysis.order_ids) ? analysis.order_ids : (analysis.order_id ? [analysis.order_id] : []);\n  const trackingNumbers = Array.isArray(analysis.tracking_numbers) ? analysis.tracking_numbers : (analysis.tracking_number ? [analysis.tracking_number] : []);\n  \n  // Determine effective store (for carrier/payment/logistics emails, use mentioned_store)\n  const senderType = analysis.sender_type || 'shop';\n  const needsMentionedStore = ['carrier', 'payment_provider', 'logistics'].includes(senderType);\n  const effectiveStore = needsMentionedStore \n    ? (analysis.mentioned_store || analysis.store || 'unknown')\n    : (analysis.store || 'unknown');\n  \n  const storeName = effectiveStore.toLowerCase().replace(/[^a-z0-9]/g, '');\n  const primaryOrderId = orderIds[0] || '';\n  \n  // Generate order key: prefer store+orderId, fallback to store+tracking, then store+emailId\n  let orderKey;\n  if (primaryOrderId) {\n    orderKey = `${storeName}_${primaryOrderId.replace(/[^a-z0-9]/gi, '')}`;\n  } else if (trackingNumbers[0]) {\n    orderKey = `${storeName}_track_${trackingNumbers[0].replace(/[^a-z0-9]/gi, '')}`;\n  } else {\n    orderKey = `${storeName}_${emailData.id || Date.now()}`;\n  }\n  \n  const now = new Date().toISOString();\n  const emailDate = emailData.date ? new Date(emailData.date).toISOString().split('T')[0] : now.split('T')[0];\n  \n  // Extract email from 'Name <email@domain.com>' format\n  const emailMatch = (emailData.from || '').match(/<([^>]+)>/);\n  const emailAccount = emailMatch ? emailMatch[1] : emailData.from || '';\n  \n  results.push({\n    json: {\n      skip: false,\n      orderKey,\n      senderType,\n      effectiveStore,\n      analysis,\n      // Arrays for matching\n      orderIds,\n      trackingNumbers,\n      mentionedStore: analysis.mentioned_store || null,\n      emailData: {\n        id: emailData.id,\n        threadId: emailData.threadId,\n        subject: emailData.subject,\n        from: emailData.from,\n        date: emailData.date,\n        owner: emailData.owner\n      },\n      rowData: {\n        order_key: orderKey,\n        order_id: orderIds.join(', '),\n        owner: emailData.owner || 'Unknown',\n        email_account: emailAccount,\n        store: effectiveStore,\n        item_description: (analysis.item_description || '').substring(0, 100),\n        order_date: analysis.email_type === 'order_confirmation' ? emailDate : '',\n        amount: analysis.amount || '',\n        currency: analysis.currency || 'EUR',\n        status: analysis.status || 'unknown',\n        delivery_provider: analysis.delivery_provider || '',\n        tracking_numbers: trackingNumbers.join(', '),\n        tracking_url: analysis.tracking_url || '',\n        store_order_url: analysis.store_order_url || '',\n        expected_delivery: analysis.expected_delivery || '',\n        actual_delivery: analysis.status === 'delivered' ? emailDate : '',\n        last_updated: now,\n        last_email_subject: emailData.subject || '',\n        last_email_date: emailData.date || '',\n        notes: analysis.notes || ''\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "parse-response",
      "name": "Parse Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1520, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-skip",
      "name": "Skip?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1740, 500]
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "options": {}
      },
      "id": "fetch-all-orders",
      "name": "Fetch All Orders",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [1960, 600],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Decide: Create new or Update existing (v2 with 3-level matching)\n// Handles: multiple tracking numbers, carrierâ†’shop linking, split shipments\n\n// Helper: Merge order data with status progression\nfunction mergeOrderData(existing, incoming) {\n  const STATUS_ORDER = ['unknown', 'ordered', 'confirmed', 'processing', 'shipped', 'in_transit', 'out_for_delivery', 'delivered', 'delivery_failed', 'returned', 'cancelled'];\n  const merged = { ...existing };\n  \n  // Status: only progress forward (unless returned/cancelled/failed)\n  const oldIdx = STATUS_ORDER.indexOf(existing.status || 'unknown');\n  const newIdx = STATUS_ORDER.indexOf(incoming.status || 'unknown');\n  if (newIdx > oldIdx || ['returned', 'cancelled', 'delivery_failed'].includes(incoming.status)) {\n    merged.status = incoming.status;\n  }\n  \n  // Fill in missing fields (don't overwrite existing)\n  const fillFields = ['tracking_url', 'store_order_url', 'delivery_provider', 'expected_delivery', 'order_id', 'amount', 'currency', 'item_description'];\n  for (const field of fillFields) {\n    if (!merged[field] && incoming[field]) {\n      merged[field] = incoming[field];\n    }\n  }\n  \n  // Tracking numbers: merge arrays (for split shipments)\n  const existingTrackings = (merged.tracking_numbers || '').split(', ').filter(t => t);\n  const incomingTrackings = (incoming.tracking_numbers || '').split(', ').filter(t => t);\n  const allTrackings = [...new Set([...existingTrackings, ...incomingTrackings])];\n  merged.tracking_numbers = allTrackings.join(', ');\n  \n  // Order date: prefer earlier (confirmation email)\n  if (!merged.order_date && incoming.order_date) {\n    merged.order_date = incoming.order_date;\n  }\n  \n  // Actual delivery: set when status is delivered\n  if (!merged.actual_delivery && incoming.actual_delivery) {\n    merged.actual_delivery = incoming.actual_delivery;\n  }\n  \n  // Always update these\n  merged.last_updated = incoming.last_updated;\n  merged.last_email_subject = incoming.last_email_subject;\n  merged.last_email_date = incoming.last_email_date;\n  \n  // Append notes (avoid duplicates)\n  if (incoming.notes && !merged.notes?.includes(incoming.notes)) {\n    merged.notes = merged.notes ? merged.notes + ' | ' + incoming.notes : incoming.notes;\n  }\n  \n  return merged;\n}\n\n// Build lookup maps from existing sheet data\nconst existingOrders = $input.all().map(item => item.json);\nconst existingByKey = new Map();      // order_key -> row\nconst existingByTracking = new Map(); // tracking_number -> order_key\nconst existingByOrderId = new Map();  // store_orderid -> order_key\n\nexistingOrders.forEach(order => {\n  if (order.order_key) {\n    existingByKey.set(order.order_key, order);\n    \n    // Index by ALL tracking numbers (split on comma)\n    if (order.tracking_numbers) {\n      order.tracking_numbers.split(', ').forEach(tn => {\n        if (tn) existingByTracking.set(tn.trim(), order.order_key);\n      });\n    }\n    // Legacy: also check old tracking_number field\n    if (order.tracking_number) {\n      existingByTracking.set(order.tracking_number, order.order_key);\n    }\n    \n    // Index by store+orderId for cross-reference\n    if (order.order_id && order.store) {\n      const storeNorm = String(order.store).toLowerCase().replace(/[^a-z0-9]/g, '');\n      String(order.order_id).split(', ').forEach(oid => {\n        if (oid) existingByOrderId.set(`${storeNorm}_${oid.trim()}`, order.order_key);\n      });\n    }\n  }\n});\n\n// Get all parsed items (non-skipped)\nconst parsedItems = $('Parse Response').all().filter(p => !p.json.skip);\n\n// Track pending creates to avoid duplicates within same run\nconst pendingCreates = new Map(); // order_key -> rowData\nconst results = [];\n\nfor (const item of parsedItems) {\n  const parsed = item.json;\n  if (!parsed || !parsed.rowData) continue;\n  \n  let orderKey = parsed.orderKey;\n  let existingRow = existingByKey.get(orderKey);\n  let matchMethod = existingRow ? 'direct_key' : null;\n  \n  // LEVEL 1: Direct order_key match (already checked above)\n  \n  // LEVEL 2: Try matching by any tracking number\n  if (!existingRow && parsed.trackingNumbers?.length > 0) {\n    for (const tn of parsed.trackingNumbers) {\n      const keyByTracking = existingByTracking.get(tn);\n      if (keyByTracking) {\n        orderKey = keyByTracking;\n        existingRow = existingByKey.get(keyByTracking);\n        matchMethod = 'tracking_number';\n        break;\n      }\n    }\n  }\n  \n  // LEVEL 3: For carrier/payment/logistics emails, try mentioned_store + tracking\n  const needsMentionedStoreMatch = ['carrier', 'payment_provider', 'logistics'].includes(parsed.senderType);\n  if (!existingRow && needsMentionedStoreMatch && parsed.mentionedStore) {\n    const mentionedStoreNorm = parsed.mentionedStore.toLowerCase().replace(/[^a-z0-9]/g, '');\n    // Try to find order from that store with any of our tracking numbers\n    for (const tn of (parsed.trackingNumbers || [])) {\n      const potentialKey = existingByTracking.get(tn);\n      if (potentialKey) {\n        const potentialOrder = existingByKey.get(potentialKey);\n        if (potentialOrder) {\n          const orderStoreNorm = (potentialOrder.store || '').toLowerCase().replace(/[^a-z0-9]/g, '');\n          if (orderStoreNorm === mentionedStoreNorm || mentionedStoreNorm.includes(orderStoreNorm) || orderStoreNorm.includes(mentionedStoreNorm)) {\n            orderKey = potentialKey;\n            existingRow = potentialOrder;\n            matchMethod = 'carrier_store_link';\n            break;\n          }\n        }\n      }\n    }\n  }\n  \n  // LEVEL 3b: Try order_id + store match (for cross-email linking)\n  if (!existingRow && parsed.orderIds?.length > 0 && parsed.effectiveStore) {\n    const storeNorm = parsed.effectiveStore.toLowerCase().replace(/[^a-z0-9]/g, '');\n    for (const oid of parsed.orderIds) {\n      const lookupKey = `${storeNorm}_${oid.trim()}`;\n      const foundKey = existingByOrderId.get(lookupKey);\n      if (foundKey) {\n        orderKey = foundKey;\n        existingRow = existingByKey.get(foundKey);\n        matchMethod = 'store_orderid';\n        break;\n      }\n    }\n  }\n  \n  // Check pending creates too\n  let pendingData = pendingCreates.get(orderKey);\n  if (!pendingData && parsed.trackingNumbers?.length > 0) {\n    // Check if any tracking matches a pending create\n    for (const [pk, pd] of pendingCreates) {\n      const pdTrackings = (pd.tracking_numbers || '').split(', ');\n      if (parsed.trackingNumbers.some(tn => pdTrackings.includes(tn))) {\n        orderKey = pk;\n        pendingData = pd;\n        break;\n      }\n    }\n  }\n  \n  if (existingRow) {\n    // Update existing row in sheet\n    const updates = mergeOrderData(existingRow, parsed.rowData);\n    existingByKey.set(orderKey, updates);\n    \n    // Index ALL tracking numbers\n    updates.tracking_numbers?.split(', ').forEach(tn => {\n      if (tn) existingByTracking.set(tn.trim(), orderKey);\n    });\n    \n    results.push({ json: { action: 'update', orderKey, matchMethod, data: updates } });\n    \n  } else if (pendingData) {\n    // Already planning to create - merge\n    const merged = mergeOrderData(pendingData, parsed.rowData);\n    pendingCreates.set(orderKey, merged);\n    \n    // Index tracking numbers\n    merged.tracking_numbers?.split(', ').forEach(tn => {\n      if (tn) existingByTracking.set(tn.trim(), orderKey);\n    });\n    \n  } else {\n    // Truly new order\n    pendingCreates.set(orderKey, parsed.rowData);\n    \n    // Index tracking numbers for subsequent emails\n    parsed.trackingNumbers?.forEach(tn => {\n      existingByTracking.set(tn, orderKey);\n    });\n    \n    // Index order IDs\n    if (parsed.orderIds?.length > 0 && parsed.effectiveStore) {\n      const storeNorm = parsed.effectiveStore.toLowerCase().replace(/[^a-z0-9]/g, '');\n      parsed.orderIds.forEach(oid => {\n        existingByOrderId.set(`${storeNorm}_${oid.trim()}`, orderKey);\n      });\n    }\n    \n    results.push({ json: { action: 'create', orderKey, data: parsed.rowData } });\n  }\n}\n\n// Update create results with merged data\nfor (let i = 0; i < results.length; i++) {\n  if (results[i].json.action === 'create') {\n    const key = results[i].json.orderKey;\n    results[i].json.data = pendingCreates.get(key);\n  }\n}\n\nif (results.length === 0) {\n  return [{ json: { action: 'none', message: 'No items to process' } }];\n}\n\nreturn results;"
      },
      "id": "decide-action",
      "name": "Decide Action",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2180, 600]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputLabel": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "update",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputLabel": "Update"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "none",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputLabel": "None"
            }
          ]
        },
        "options": {
          "fallbackOutput": "none"
        }
      },
      "id": "switch-action",
      "name": "Switch: Action",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [2400, 600]
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "order_key": "={{ $json.data.order_key }}",
            "order_id": "={{ $json.data.order_id }}",
            "owner": "={{ $json.data.owner }}",
            "email_account": "={{ $json.data.email_account }}",
            "store": "={{ $json.data.store }}",
            "item_description": "={{ $json.data.item_description }}",
            "order_date": "={{ $json.data.order_date }}",
            "amount": "={{ $json.data.amount }}",
            "currency": "={{ $json.data.currency }}",
            "status": "={{ $json.data.status }}",
            "delivery_provider": "={{ $json.data.delivery_provider }}",
            "tracking_numbers": "={{ $json.data.tracking_numbers }}",
            "tracking_url": "={{ $json.data.tracking_url }}",
            "store_order_url": "={{ $json.data.store_order_url }}",
            "expected_delivery": "={{ $json.data.expected_delivery }}",
            "actual_delivery": "={{ $json.data.actual_delivery }}",
            "last_updated": "={{ $json.data.last_updated }}",
            "last_email_subject": "={{ $json.data.last_email_subject }}",
            "last_email_date": "={{ $json.data.last_email_date }}",
            "notes": "={{ $json.data.notes }}"
          }
        },
        "options": {}
      },
      "id": "sheets-create",
      "name": "Sheets: Create",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [2620, 500],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "order_key": "={{ $json.orderKey }}",
            "status": "={{ $json.data.status }}",
            "delivery_provider": "={{ $json.data.delivery_provider }}",
            "tracking_numbers": "={{ $json.data.tracking_numbers }}",
            "tracking_url": "={{ $json.data.tracking_url }}",
            "store_order_url": "={{ $json.data.store_order_url }}",
            "expected_delivery": "={{ $json.data.expected_delivery }}",
            "actual_delivery": "={{ $json.data.actual_delivery }}",
            "last_updated": "={{ $json.data.last_updated }}",
            "last_email_subject": "={{ $json.data.last_email_subject }}",
            "last_email_date": "={{ $json.data.last_email_date }}",
            "notes": "={{ $json.data.notes }}"
          }
        },
        "options": {}
      },
      "id": "sheets-update",
      "name": "Sheets: Update",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [2620, 700],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {},
      "id": "noop-end",
      "name": "Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2840, 600]
    }
  ],
  "connections": {
    "Schedule (Every 3h)": {
      "main": [
        [
          { "node": "Config", "type": "main", "index": 0 }
        ]
      ]
    },
    "Config": {
      "main": [
        [
          { "node": "Gmail: Get Emails", "type": "main", "index": 0 }
        ]
      ]
    },
    "Gmail: Get Emails": {
      "main": [
        [
          { "node": "Filter: Order Emails", "type": "main", "index": 0 }
        ]
      ]
    },
    "Filter: Order Emails": {
      "main": [
        [
          { "node": "Has Emails?", "type": "main", "index": 0 }
        ]
      ]
    },
    "Has Emails?": {
      "main": [
        [],
        [
          { "node": "Prepare Claude Request", "type": "main", "index": 0 }
        ]
      ]
    },
    "Prepare Claude Request": {
      "main": [
        [
          { "node": "Analyze with Claude", "type": "main", "index": 0 }
        ]
      ]
    },
    "Analyze with Claude": {
      "main": [
        [
          { "node": "Parse Response", "type": "main", "index": 0 }
        ]
      ]
    },
    "Parse Response": {
      "main": [
        [
          { "node": "Skip?", "type": "main", "index": 0 }
        ]
      ]
    },
    "Skip?": {
      "main": [
        [
          { "node": "Done", "type": "main", "index": 0 }
        ],
        [
          { "node": "Fetch All Orders", "type": "main", "index": 0 }
        ]
      ]
    },
    "Fetch All Orders": {
      "main": [
        [
          { "node": "Decide Action", "type": "main", "index": 0 }
        ]
      ]
    },
    "Decide Action": {
      "main": [
        [
          { "node": "Switch: Action", "type": "main", "index": 0 }
        ]
      ]
    },
    "Switch: Action": {
      "main": [
        [
          { "node": "Sheets: Create", "type": "main", "index": 0 }
        ],
        [
          { "node": "Sheets: Update", "type": "main", "index": 0 }
        ],
        [
          { "node": "Done", "type": "main", "index": 0 }
        ]
      ]
    },
    "Sheets: Create": {
      "main": [
        [
          { "node": "Done", "type": "main", "index": 0 }
        ]
      ]
    },
    "Sheets: Update": {
      "main": [
        [
          { "node": "Done", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}

