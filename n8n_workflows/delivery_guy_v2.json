{
  "name": "ðŸšš Delivery Guy v2 (Sequential)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 3
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule (Every 3h)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [200, 400]
    },
    {
      "parameters": {
        "jsCode": "// Configuration\nconst OWNER = 'Artem'; // Change this to your name\nconst SHEET_ID = '1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q';\n\nreturn {\n  owner: OWNER,\n  sheetId: SHEET_ID\n};"
      },
      "id": "config",
      "name": "Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 400]
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": false,
        "limit": 100,
        "filters": {
          "q": "=newer_than:5d {order OR bestellung OR shipped OR versandt OR tracking OR sendung OR delivery OR lieferung OR zustellung OR paket OR package OR confirmation OR bestÃ¤tigung OR dispatch OR shipment OR arriving OR courier OR abholung OR zugestellt OR deine OR your}"
        },
        "options": {
          "labelIds": ["INBOX"]
        }
      },
      "id": "gmail-get-emails",
      "name": "Gmail: Get Emails",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [600, 400],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter emails - lightweight pre-filter before Claude\nconst emails = $input.all();\nconst config = $('Config').first().json;\n\n// EXCLUDED SENDERS - skip entirely (payment providers, social media, security alerts)\nconst EXCLUDED_SENDERS = [\n  'klarna', 'paypal', 'stripe',           // Payment providers\n  'newsletter', 'marketing', 'promo',      // Marketing\n  'instagram', 'facebook', 'twitter', 'linkedin', 'tiktok',  // Social media\n  'accounts.google', 'security@',          // Security alerts\n  'lovable', 'github', 'gitlab',           // Dev tools\n  'spotify', 'netflix', 'apple.com'        // Subscriptions\n];\n\n// Keywords that indicate order/delivery emails\nconst ORDER_KEYWORDS = [\n  'order confirmation', 'order #', 'your order', 'order placed', 'order received',\n  'shipped', 'shipping', 'has shipped', 'tracking', 'track your', 'track package',\n  'delivery', 'delivered', 'out for delivery', 'arriving', 'dispatched', 'dispatch',\n  'package', 'parcel', 'shipment', 'courier',\n  'bestellbestÃ¤tigung', 'bestellung', 'bestellt', 'deine bestellung',\n  'versandt', 'versand', 'sendungsverfolgung', 'verfolgen',\n  'lieferung', 'zustellung', 'zugestellt', 'unterwegs', 'abholung',\n  'paket', 'sendung', 'deine sendung', 'ihr paket'\n];\n\n// KNOWN SENDERS - bypass keyword check (be specific, NOT generic like 'noreply')\nconst KNOWN_SENDERS = [\n  // Retailers\n  'amazon', 'zalando', 'asos', 'aboutyou', 'otto', 'hm.com', 'zara',\n  'ebay', 'etsy', 'aliexpress', 'mediamarkt', 'saturn', 'ikea',\n  'gorewear', 'massimo', 'massimodutti', 'arys', 'sendcloud',\n  // Carriers (important - their emails may have generic subjects)\n  'dhl', 'dpd', 'hermes', 'myhermes', 'ups', 'gls', 'fedex',\n  'post.ch', 'swisspost', 'deutschepost', 'laposte',\n  'gls-pakete', 'paketankuendigung'\n];\n\nconst results = [];\n\nfor (const item of emails) {\n  const email = item.json;\n  const subject = (email.Subject || email.subject || '').toLowerCase();\n  const from = (email.From || email.from || '').toLowerCase();\n  const snippet = (email.snippet || '').toLowerCase();\n  \n  // Skip excluded senders\n  if (EXCLUDED_SENDERS.some(ex => from.includes(ex))) continue;\n  \n  const matchesKeyword = ORDER_KEYWORDS.some(kw => subject.includes(kw) || snippet.includes(kw));\n  const matchesSender = KNOWN_SENDERS.some(s => from.includes(s));\n  \n  if (matchesKeyword || matchesSender) {\n    const dateMs = parseInt(email.internalDate) || Date.now();\n    results.push({\n      json: {\n        id: email.id,\n        threadId: email.threadId,\n        subject: email.Subject || email.subject || '',\n        from: email.From || email.from || '',\n        date: new Date(dateMs).toISOString(),\n        snippet: email.snippet || '',\n        textPlain: email.textPlain || email.snippet || '',\n        owner: config.owner\n      }\n    });\n  }\n}\n\nif (results.length === 0) {\n  return [{ json: { noEmails: true, message: 'No order-related emails found' } }];\n}\n\n// Sort by date ASCENDING (oldest first) for proper chronological processing\nresults.sort((a, b) => new Date(a.json.date) - new Date(b.json.date));\n\nreturn results;"
      },
      "id": "filter-emails",
      "name": "Filter: Order Emails",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.noEmails }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-emails",
      "name": "Has Emails?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "loop-emails",
      "name": "Loop Over Emails",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1200, 500]
    },
    {
      "parameters": {
        "operation": "get",
        "messageId": "={{ $json.id }}",
        "options": {
          "dataPropertyAttachmentsPrefixName": "attachment_",
          "downloadAttachments": false
        },
        "simple": false
      },
      "id": "gmail-get-full",
      "name": "Gmail: Get Full Message",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [1400, 500],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_CREDENTIAL_ID",
          "name": "Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge full email body with filtered email metadata\nconst fullEmail = $input.first().json;\nconst filteredEmail = $('Loop Over Emails').first().json;\n\n// Clean up text - remove image URLs, tracking pixels, excessive whitespace\nfunction cleanText(text) {\n  if (!text) return '';\n  return text\n    .replace(/\\[https?:\\/\\/[^\\]]+\\]/g, '')  // Remove [http://...] markdown links\n    .replace(/https?:\\/\\/ir\\.[^\\s]+/g, '')  // Remove tracking URLs\n    .replace(/https?:\\/\\/static\\.[^\\s]+\\.(jpg|png|gif)/gi, '')  // Remove image URLs\n    .replace(/\\n{3,}/g, '\\n\\n')  // Collapse multiple newlines\n    .replace(/^\\s+$/gm, '')  // Remove whitespace-only lines\n    .trim()\n    .substring(0, 12000);  // Limit size for Claude\n}\n\n// Gmail returns 'text' and 'html' directly when simple=false\nlet textContent = '';\n\n// Priority 1: Direct 'text' field from Gmail\nif (fullEmail.text) {\n  textContent = cleanText(fullEmail.text);\n}\n\n// Priority 2: Direct 'html' field - strip tags\nif (!textContent && fullEmail.html) {\n  const stripped = fullEmail.html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&#\\d+;/g, '')\n    .replace(/\\s+/g, ' ');\n  textContent = cleanText(stripped);\n}\n\n// Priority 3: textPlain field (some Gmail versions)\nif (!textContent && fullEmail.textPlain) {\n  textContent = cleanText(fullEmail.textPlain);\n}\n\n// Priority 4: Snippet as fallback\nif (!textContent) {\n  textContent = fullEmail.snippet || filteredEmail.snippet || '';\n}\n\nreturn {\n  id: filteredEmail.id,\n  threadId: filteredEmail.threadId,\n  subject: filteredEmail.subject,\n  from: filteredEmail.from,\n  date: filteredEmail.date,\n  snippet: filteredEmail.snippet,\n  textPlain: textContent,\n  textLength: textContent.length,  // Debug: see how much content we got\n  owner: filteredEmail.owner\n};"
      },
      "id": "merge-email-data",
      "name": "Merge Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 500]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Claude request for single email\nconst email = $input.first().json;\n\nconst prompt = `You are Delivery Guy, an expert at extracting order/delivery information from emails.\n\nANALYZE THIS EMAIL:\n\nSubject: ${email.subject || 'N/A'}\nFrom: ${email.from || 'N/A'}\nDate: ${email.date || 'N/A'}\n\n--- EMAIL BODY ---\n${email.textPlain || email.snippet || 'N/A'}\n--- END ---\n\nEXTRACT and respond with valid JSON ONLY:\n{\n  \"is_order_related\": true/false,\n  \"email_type\": \"order_confirmation|shipping_notification|delivery_update|out_for_delivery|delivered|invoice|return|other\",\n  \"sender_type\": \"shop|carrier|logistics|marketplace\",\n  \"store\": \"BRAND/STORE name (e.g. Massimo Dutti, Zalando, GOREWEAR)\",\n  \"mentioned_store\": \"store mentioned in carrier emails (e.g. 'von Zalando'), or null\",\n  \"order_ids\": [\"ALL order numbers found\"],\n  \"tracking_numbers\": [\"ALL tracking numbers found\"],\n  \"reference_numbers\": [\"ALL reference numbers (Referenz, Reference) - may contain order IDs\"],\n  \"item_description\": \"DETAILED list of items (names, colors, sizes)\",\n  \"amount\": total order amount as number,\n  \"currency\": \"EUR|USD|CHF|GBP\",\n  \"status\": \"ordered|confirmed|processing|shipped|in_transit|out_for_delivery|delivered|returned|unknown\",\n  \"delivery_provider\": \"carrier name if mentioned\",\n  \"tracking_url\": \"URL containing tracking/sendung/parcel + number, or null\",\n  \"store_order_url\": \"URL to order page on store website (contains 'order', 'myaccount'), or null\",\n  \"expected_delivery\": \"YYYY-MM-DD (convert 30.12.2025 to 2025-12-30, use first date if range)\",\n  \"delivery_address\": \"city or address if visible\",\n  \"notes\": \"any important details (delays, issues, special instructions)\"\n}\n\nEXTRACTION RULES:\n1. ITEMS: List ALL products with details (name, color, size, quantity, price)\n2. AMOUNT: Extract total/subtotal as number (139.80 from '139.80 â‚¬')\n3. DATES: Convert to YYYY-MM-DD. '30.12.2025' = '2025-12-30'. For ranges use first date.\n4. STORE: For carrier emails (DHL, Hermes, GLS), look for 'von X', 'from X', 'Sendung von X'\n5. TRACKING: Look for long alphanumeric codes (DHL: 20 digits, GLS: alphanumeric, Hermes: H102..., JD000...)\n6. URLs: Extract order page URLs (my-account/orders, order-detail) and tracking URLs\n7. ADDRESS: Extract delivery city/address if present`;\n\nconst requestBody = {\n  model: 'claude-sonnet-4-20250514',\n  max_tokens: 1500,\n  messages: [{ role: 'user', content: prompt }]\n};\n\nreturn { requestBody, emailData: email };"
      },
      "id": "prepare-claude",
      "name": "Prepare Claude",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "anthropic-version", "value": "2023-06-01" },
            { "name": "content-type", "value": "application/json" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "id": "claude-analyze",
      "name": "Claude: Analyze",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2000, 500],
      "credentials": {
        "httpHeaderAuth": {
          "id": "CLAUDE_CREDENTIAL_ID",
          "name": "Claude Api Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Claude response for single email\nconst response = $input.first().json;\nconst emailData = $('Merge Email Data').first().json;\n\nlet analysis;\ntry {\n  const content = response.content?.[0]?.text || '{}';\n  const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n  analysis = jsonMatch ? JSON.parse(jsonMatch[0]) : { is_order_related: false };\n} catch (e) {\n  analysis = { is_order_related: false, error: e.message };\n}\n\nif (!analysis.is_order_related) {\n  return { skip: true, reason: analysis.email_type || 'not_order_related' };\n}\n\n// Normalize arrays\nconst orderIds = Array.isArray(analysis.order_ids) ? analysis.order_ids : (analysis.order_id ? [analysis.order_id] : []);\nconst trackingNumbers = Array.isArray(analysis.tracking_numbers) ? analysis.tracking_numbers : (analysis.tracking_number ? [analysis.tracking_number] : []);\nconst referenceNumbers = Array.isArray(analysis.reference_numbers) ? analysis.reference_numbers : [];\n\n// Determine effective store\nconst senderType = analysis.sender_type || 'shop';\nconst needsMentionedStore = ['carrier', 'logistics'].includes(senderType);\nconst effectiveStore = needsMentionedStore \n  ? (analysis.mentioned_store || analysis.store || 'unknown')\n  : (analysis.store || 'unknown');\n\nconst storeName = effectiveStore.toLowerCase().replace(/[^a-z0-9]/g, '');\nconst primaryOrderId = orderIds[0] || '';\n\n// Generate order key\nlet orderKey;\nif (primaryOrderId) {\n  orderKey = `${storeName}_${String(primaryOrderId).replace(/[^a-z0-9]/gi, '')}`;\n} else if (trackingNumbers[0]) {\n  orderKey = `${storeName}_track_${trackingNumbers[0].replace(/[^a-z0-9]/gi, '')}`;\n} else {\n  orderKey = `${storeName}_${emailData.id || Date.now()}`;\n}\n\nconst now = new Date().toISOString();\nconst emailDate = emailData.date ? new Date(emailData.date).toISOString().split('T')[0] : now.split('T')[0];\n\n// Extract email address\nconst emailMatch = (emailData.from || '').match(/<([^>]+)>/);\nconst emailAccount = emailMatch ? emailMatch[1] : emailData.from || '';\n\nreturn {\n  skip: false,\n  orderKey,\n  senderType,\n  effectiveStore,\n  orderIds,\n  trackingNumbers,\n  referenceNumbers,\n  mentionedStore: analysis.mentioned_store || null,\n  rowData: {\n    order_key: orderKey,\n    order_id: orderIds.join(', '),\n    owner: emailData.owner || 'Unknown',\n    email_account: emailAccount,\n    store: effectiveStore,\n    item_description: (analysis.item_description || '').substring(0, 100),\n    order_date: analysis.email_type === 'order_confirmation' ? emailDate : '',\n    amount: analysis.amount || '',\n    currency: analysis.currency || 'EUR',\n    status: analysis.status || 'unknown',\n    delivery_provider: analysis.delivery_provider || '',\n    tracking_numbers: trackingNumbers.join(', '),\n    tracking_url: analysis.tracking_url || '',\n    store_order_url: analysis.store_order_url || '',\n    expected_delivery: analysis.expected_delivery || '',\n    actual_delivery: analysis.status === 'delivered' ? emailDate : '',\n    last_updated: now,\n    last_email_subject: emailData.subject || '',\n    last_email_date: emailData.date || '',\n    delivery_address: analysis.delivery_address || '',\n    notes: analysis.notes || ''\n  }\n};"
      },
      "id": "parse-response",
      "name": "Parse Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-skip",
      "name": "Skip?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2400, 500]
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "options": {}
      },
      "id": "fetch-orders",
      "name": "Fetch Orders",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [2600, 600],
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Find matching order and decide: CREATE or UPDATE\nconst parsed = $('Parse Response').first().json;\nconst allItems = $input.all();\n// Handle empty sheet - filter out empty items\nconst existingOrders = allItems.filter(item => item.json && Object.keys(item.json).length > 0).map(item => item.json);\n\n// Helper: Generate multiple match keys from an identifier\n// This handles different separator meanings:\n// - Dots are usually formatting (99.60.xxx â†’ 9960xxx)\n// - Dashes are usually separators (XXX-30101502670 â†’ split into parts)\nfunction generateMatchKeys(identifier) {\n  if (!identifier) return [];\n  const id = String(identifier).trim();\n  if (!id) return [];\n  \n  const keys = new Set();\n  \n  // 1. Original (case-insensitive)\n  keys.add(id.toUpperCase());\n  \n  // 2. Dots removed only (Swiss Post style: 99.60.xxx â†’ 9960xxx)\n  const dotsRemoved = id.replace(/\\./g, '').toUpperCase();\n  keys.add(dotsRemoved);\n  \n  // 3. Split on dashes and underscores (compound references)\n  id.split(/[-_]/).forEach(part => {\n    const trimmed = part.trim();\n    if (trimmed.length >= 5) {  // Only meaningful parts\n      keys.add(trimmed.toUpperCase());\n      keys.add(trimmed.replace(/\\./g, '').toUpperCase());\n    }\n  });\n  \n  // 4. All number sequences >= 6 digits (catch embedded IDs)\n  const numbers = id.match(/\\d{6,}/g) || [];\n  numbers.forEach(n => keys.add(n));\n  \n  return [...keys];\n}\n\n// Build lookup maps with multi-key indexing\nconst byKey = new Map();           // order_key -> order\nconst byIdentifier = new Map();    // any identifier variation -> order_key\nconst byStoreOrderId = new Map();  // store_orderid -> order_key\n\nexistingOrders.forEach(order => {\n  if (order.order_key) {\n    byKey.set(order.order_key, order);\n    \n    // Index ALL tracking numbers with ALL their variations\n    if (order.tracking_numbers) {\n      String(order.tracking_numbers).split(', ').forEach(tn => {\n        generateMatchKeys(tn).forEach(key => {\n          byIdentifier.set(key, order.order_key);\n        });\n      });\n    }\n    \n    // Index order IDs with ALL their variations\n    if (order.order_id) {\n      String(order.order_id).split(', ').forEach(oid => {\n        generateMatchKeys(oid).forEach(key => {\n          byIdentifier.set(key, order.order_key);\n        });\n        // Also store+orderId combo\n        if (order.store) {\n          const storeNorm = String(order.store).toLowerCase().replace(/[^a-z0-9]/g, '');\n          byStoreOrderId.set(`${storeNorm}_${oid.trim()}`, order.order_key);\n        }\n      });\n    }\n  }\n});\n\nlet orderKey = parsed.orderKey;\nlet existingOrder = byKey.get(orderKey);\nlet matchMethod = existingOrder ? 'direct_key' : null;\n\n// Helper: Try to find match using multi-key strategy\nfunction findByIdentifier(identifier) {\n  const keys = generateMatchKeys(identifier);\n  for (const key of keys) {\n    const found = byIdentifier.get(key);\n    if (found) return found;\n  }\n  return null;\n}\n\n// Level 2: Try tracking numbers (using multi-key matching)\nif (!existingOrder && parsed.trackingNumbers?.length > 0) {\n  for (const tn of parsed.trackingNumbers) {\n    const foundKey = findByIdentifier(tn);\n    if (foundKey) {\n      orderKey = foundKey;\n      existingOrder = byKey.get(foundKey);\n      matchMethod = 'tracking_number';\n      break;\n    }\n  }\n}\n\n// Level 3: Try order IDs (using multi-key matching)\nif (!existingOrder && parsed.orderIds?.length > 0) {\n  for (const oid of parsed.orderIds) {\n    const foundKey = findByIdentifier(oid);\n    if (foundKey) {\n      orderKey = foundKey;\n      existingOrder = byKey.get(foundKey);\n      matchMethod = 'order_id_match';\n      break;\n    }\n  }\n}\n\n// Level 4: Try store + orderId (explicit combo)\nif (!existingOrder && parsed.orderIds?.length > 0 && parsed.effectiveStore) {\n  const storeNorm = parsed.effectiveStore.toLowerCase().replace(/[^a-z0-9]/g, '');\n  for (const oid of parsed.orderIds) {\n    const lookupKey = `${storeNorm}_${String(oid).trim()}`;\n    const foundKey = byStoreOrderId.get(lookupKey);\n    if (foundKey) {\n      orderKey = foundKey;\n      existingOrder = byKey.get(foundKey);\n      matchMethod = 'store_orderid';\n      break;\n    }\n  }\n}\n\n// Level 5: Try reference numbers (split and match parts)\nif (!existingOrder && parsed.referenceNumbers?.length > 0) {\n  for (const ref of parsed.referenceNumbers) {\n    const foundKey = findByIdentifier(ref);\n    if (foundKey) {\n      orderKey = foundKey;\n      existingOrder = byKey.get(foundKey);\n      matchMethod = 'reference_match';\n      break;\n    }\n  }\n}\n\n// Level 6: Try carrier + mentioned_store validation\nif (!existingOrder && ['carrier', 'logistics'].includes(parsed.senderType) && parsed.mentionedStore) {\n  const mentionedNorm = parsed.mentionedStore.toLowerCase().replace(/[^a-z0-9]/g, '');\n  // Try all identifiers and validate store matches\n  const allIds = [...(parsed.trackingNumbers || []), ...(parsed.referenceNumbers || [])];\n  for (const id of allIds) {\n    const foundKey = findByIdentifier(id);\n    if (foundKey) {\n      const order = byKey.get(foundKey);\n      if (order) {\n        const orderStoreNorm = String(order.store || '').toLowerCase().replace(/[^a-z0-9]/g, '');\n        if (orderStoreNorm.includes(mentionedNorm) || mentionedNorm.includes(orderStoreNorm)) {\n          orderKey = foundKey;\n          existingOrder = order;\n          matchMethod = 'carrier_store_verified';\n          break;\n        }\n      }\n    }\n  }\n}\n\n// Check for duplicate records that should be merged\n// This handles: carrier email arrives before store shipping notification\nlet duplicateToDelete = null;\nif (existingOrder && parsed.trackingNumbers?.length > 0) {\n  // We found a match - but check if there's ANOTHER record with same tracking\n  for (const tn of parsed.trackingNumbers) {\n    const keys = generateMatchKeys(tn);\n    for (const key of keys) {\n      const otherKey = byIdentifier.get(key);\n      if (otherKey && otherKey !== orderKey) {\n        const otherOrder = byKey.get(otherKey);\n        // If other record has no order_id (carrier-created), mark for merge\n        if (otherOrder && !otherOrder.order_id) {\n          duplicateToDelete = otherKey;\n          // Merge tracking numbers from duplicate\n          if (otherOrder.tracking_numbers) {\n            parsed.trackingNumbers.push(...String(otherOrder.tracking_numbers).split(', '));\n          }\n          if (otherOrder.tracking_url && !parsed.rowData.tracking_url) {\n            parsed.rowData.tracking_url = otherOrder.tracking_url;\n          }\n          break;\n        }\n      }\n    }\n    if (duplicateToDelete) break;\n  }\n}\n\nif (existingOrder) {\n  // MERGE data for UPDATE\n  const STATUS_ORDER = ['unknown', 'ordered', 'confirmed', 'processing', 'shipped', 'in_transit', 'out_for_delivery', 'delivered', 'returned'];\n  const merged = { ...existingOrder };\n  const incoming = parsed.rowData;\n  \n  // If we found a duplicate, merge its data too\n  if (duplicateToDelete) {\n    const dupOrder = byKey.get(duplicateToDelete);\n    if (dupOrder) {\n      ['tracking_url', 'delivery_provider', 'expected_delivery', 'delivery_address'].forEach(f => {\n        if (!merged[f] && dupOrder[f]) merged[f] = dupOrder[f];\n      });\n      // Merge tracking numbers from duplicate\n      const dupTN = String(dupOrder.tracking_numbers || '').split(', ').filter(t => t);\n      incoming.tracking_numbers = incoming.tracking_numbers + ', ' + dupTN.join(', ');\n    }\n  }\n  \n  // Status: only progress forward\n  const oldIdx = STATUS_ORDER.indexOf(merged.status || 'unknown');\n  const newIdx = STATUS_ORDER.indexOf(incoming.status || 'unknown');\n  if (newIdx > oldIdx || incoming.status === 'returned') {\n    merged.status = incoming.status;\n  }\n  \n  // Fill missing fields\n  ['tracking_url', 'store_order_url', 'delivery_provider', 'expected_delivery', 'amount', 'currency', 'item_description', 'delivery_address'].forEach(f => {\n    if (!merged[f] && incoming[f]) merged[f] = incoming[f];\n  });\n  \n  // Merge tracking numbers (handle arrays or strings)\n  const existingTN = String(merged.tracking_numbers || '').split(', ').filter(t => t);\n  const incomingTN = String(incoming.tracking_numbers || '').split(', ').filter(t => t);\n  // Also add normalized versions for deduplication\n  const allTN = [...existingTN, ...incomingTN];\n  const uniqueTN = [...new Set(allTN.map(t => t.trim()).filter(t => t))];\n  merged.tracking_numbers = uniqueTN.join(', ');\n  \n  // Order date: keep existing or use incoming\n  if (!merged.order_date && incoming.order_date) merged.order_date = incoming.order_date;\n  \n  // Actual delivery\n  if (!merged.actual_delivery && incoming.actual_delivery) merged.actual_delivery = incoming.actual_delivery;\n  \n  // Always update\n  merged.last_updated = incoming.last_updated;\n  merged.last_email_subject = incoming.last_email_subject;\n  merged.last_email_date = incoming.last_email_date;\n  \n  // Append notes\n  if (incoming.notes && !merged.notes?.includes(incoming.notes)) {\n    merged.notes = merged.notes ? merged.notes + ' | ' + incoming.notes : incoming.notes;\n  }\n  \n  // Return with duplicate info for marking\n  return { action: 'update', orderKey, matchMethod, duplicateToMerge: duplicateToDelete, data: merged };\n} else {\n  return { action: 'create', orderKey, data: parsed.rowData };\n}"
      },
      "id": "find-match",
      "name": "Find Match & Merge",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2800, 600]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "create",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputLabel": "Create"
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "update",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputLabel": "Update"
            }
          ]
        },
        "options": { "fallbackOutput": "none" }
      },
      "id": "switch-action",
      "name": "Create or Update?",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [3000, 600]
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "order_key": "={{ $json.data.order_key }}",
            "order_id": "={{ $json.data.order_id }}",
            "owner": "={{ $json.data.owner }}",
            "email_account": "={{ $json.data.email_account }}",
            "store": "={{ $json.data.store }}",
            "item_description": "={{ $json.data.item_description }}",
            "order_date": "={{ $json.data.order_date }}",
            "amount": "={{ $json.data.amount }}",
            "currency": "={{ $json.data.currency }}",
            "status": "={{ $json.data.status }}",
            "delivery_provider": "={{ $json.data.delivery_provider }}",
            "tracking_numbers": "={{ $json.data.tracking_numbers }}",
            "tracking_url": "={{ $json.data.tracking_url }}",
            "store_order_url": "={{ $json.data.store_order_url }}",
            "expected_delivery": "={{ $json.data.expected_delivery }}",
            "actual_delivery": "={{ $json.data.actual_delivery }}",
            "last_updated": "={{ $json.data.last_updated }}",
            "last_email_subject": "={{ $json.data.last_email_subject }}",
            "last_email_date": "={{ $json.data.last_email_date }}",
            "delivery_address": "={{ $json.data.delivery_address }}",
            "notes": "={{ $json.data.notes }}"
          }
        },
        "options": {}
      },
      "id": "sheets-create",
      "name": "Sheets: Create",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [3200, 500],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "columnsToMatchOn": ["order_key"],
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "order_key": "={{ $json.orderKey }}",
            "order_id": "={{ $json.data.order_id }}",
            "store": "={{ $json.data.store }}",
            "item_description": "={{ $json.data.item_description }}",
            "order_date": "={{ $json.data.order_date }}",
            "amount": "={{ $json.data.amount }}",
            "currency": "={{ $json.data.currency }}",
            "status": "={{ $json.data.status }}",
            "delivery_provider": "={{ $json.data.delivery_provider }}",
            "tracking_numbers": "={{ $json.data.tracking_numbers }}",
            "tracking_url": "={{ $json.data.tracking_url }}",
            "store_order_url": "={{ $json.data.store_order_url }}",
            "expected_delivery": "={{ $json.data.expected_delivery }}",
            "actual_delivery": "={{ $json.data.actual_delivery }}",
            "last_updated": "={{ $json.data.last_updated }}",
            "last_email_subject": "={{ $json.data.last_email_subject }}",
            "last_email_date": "={{ $json.data.last_email_date }}",
            "delivery_address": "={{ $json.data.delivery_address }}",
            "notes": "={{ $json.data.notes }}"
          }
        },
        "options": {}
      },
      "id": "sheets-update",
      "name": "Sheets: Update",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [3200, 700],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    },
    {
      "parameters": {},
      "id": "noop-done",
      "name": "Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [3600, 600]
    },
    {
      "parameters": {},
      "id": "noop-no-emails",
      "name": "No Emails",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $('Find Match & Merge').item.json.duplicateToMerge }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-duplicate",
      "name": "Has Duplicate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3400, 700]
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1H_Kr_hgdlBpl6cdZbf0ZW6cBCpw7zwCoJHoXUJ-O83Q"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Orders"
        },
        "columnsToMatchOn": ["order_key"],
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "order_key": "={{ $('Find Match & Merge').item.json.duplicateToMerge }}",
            "status": "merged",
            "notes": "=Merged into: {{ $('Find Match & Merge').item.json.orderKey }}"
          }
        },
        "options": {}
      },
      "id": "sheets-mark-merged",
      "name": "Sheets: Mark Merged",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [3600, 800],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GSHEETS_CREDENTIAL_ID",
          "name": "Google Sheets"
        }
      }
    }
  ],
  "connections": {
    "Schedule (Every 3h)": {
      "main": [[{ "node": "Config", "type": "main", "index": 0 }]]
    },
    "Config": {
      "main": [[{ "node": "Gmail: Get Emails", "type": "main", "index": 0 }]]
    },
    "Gmail: Get Emails": {
      "main": [[{ "node": "Filter: Order Emails", "type": "main", "index": 0 }]]
    },
    "Filter: Order Emails": {
      "main": [[{ "node": "Has Emails?", "type": "main", "index": 0 }]]
    },
    "Has Emails?": {
      "main": [
        [{ "node": "No Emails", "type": "main", "index": 0 }],
        [{ "node": "Loop Over Emails", "type": "main", "index": 0 }]
      ]
    },
    "Loop Over Emails": {
      "main": [
        [{ "node": "Done", "type": "main", "index": 0 }],
        [{ "node": "Gmail: Get Full Message", "type": "main", "index": 0 }]
      ]
    },
    "Gmail: Get Full Message": {
      "main": [[{ "node": "Merge Email Data", "type": "main", "index": 0 }]]
    },
    "Merge Email Data": {
      "main": [[{ "node": "Prepare Claude", "type": "main", "index": 0 }]]
    },
    "Prepare Claude": {
      "main": [[{ "node": "Claude: Analyze", "type": "main", "index": 0 }]]
    },
    "Claude: Analyze": {
      "main": [[{ "node": "Parse Response", "type": "main", "index": 0 }]]
    },
    "Parse Response": {
      "main": [[{ "node": "Skip?", "type": "main", "index": 0 }]]
    },
    "Skip?": {
      "main": [
        [{ "node": "Loop Over Emails", "type": "main", "index": 0 }],
        [{ "node": "Fetch Orders", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Orders": {
      "main": [[{ "node": "Find Match & Merge", "type": "main", "index": 0 }]]
    },
    "Find Match & Merge": {
      "main": [[{ "node": "Create or Update?", "type": "main", "index": 0 }]]
    },
    "Create or Update?": {
      "main": [
        [{ "node": "Sheets: Create", "type": "main", "index": 0 }],
        [{ "node": "Sheets: Update", "type": "main", "index": 0 }]
      ]
    },
    "Sheets: Create": {
      "main": [[{ "node": "Loop Over Emails", "type": "main", "index": 0 }]]
    },
    "Sheets: Update": {
      "main": [[{ "node": "Has Duplicate?", "type": "main", "index": 0 }]]
    },
    "Has Duplicate?": {
      "main": [
        [{ "node": "Loop Over Emails", "type": "main", "index": 0 }],
        [{ "node": "Sheets: Mark Merged", "type": "main", "index": 0 }]
      ]
    },
    "Sheets: Mark Merged": {
      "main": [[{ "node": "Loop Over Emails", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}

